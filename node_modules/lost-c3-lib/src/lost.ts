
/**
 * en-US.json
 */
export namespace Lost {

    export interface LanguageParam {
        "name": string;
        "desc": string
        "items"?: {
            [itemId: string]: string;
        };
    }

    export interface LanguageCondition {
        /**
         * @description
         * the name that appears in the condition/action picker dialog.
         */
        "list-name": string;
        /**
         * @description
         * the text that appears in the event sheet. 
         * You can use simple BBCode tags like [b] and [i], and use {0}, {1} etc. as parameter placeholders.
         * (There must be one parameter placeholder per parameter.)
         * For behaviors only, the placeholder {my} is substituted for the behavior name and icon.
         */
        "display-text": string;
        /**
         * @description
         * a description of the action or condition, which appears as a tip at the top of the condition/action picker dialog.
         */
        "description": string;
        "params"?: {
            [paramId: string]: LanguageParam;
        };
    }

    export interface LanguageAction {
        /**
         * @description
         * the name that appears in the condition/action picker dialog.
         */
        "list-name": string;
        /**
         * @description
         * the text that appears in the event sheet. 
         * You can use simple BBCode tags like [b] and [i], and use {0}, {1} etc. as parameter placeholders.
         * (There must be one parameter placeholder per parameter.)
         * For behaviors only, the placeholder {my} is substituted for the behavior name and icon.
         */
        "display-text": string;
        /**
         * @description
         * a description of the action or condition, which appears as a tip at the top of the condition/action picker dialog.
         */
        "description": string;
        "params"?: {
            [paramId: string]: LanguageParam;
        };
    }

    export interface LanguageExpression {
        /**
         * @description
         * the description that appears in the expressions dictionary, which lists all available expressions.
         */
        "description": string;
        /**
         * @description
         * the translated name of the expression name. 
         * In the en-US file, this should simply match the expression name from the expression definition. 
         * This key mainly exists so it can be changed in other languages, making it possible to translate expressions in some contexts. 
         * Note when actually typing an expression the non-translated expression name must always be used.
         */
        "translated-name": string;
        "params"?: {
            [paramId: string]: LanguageParam;
        };
    }

    export interface LanguagePluginProperty {
        "name": string;
        "desc": string;
        "items"?: {
            [itemId: string]: string;
        };
    }

    export interface LanguageJSON {
        "languageTag": "en-US",
        "fileDescription": string;
        "text": {
            "plugins": {
                [pluginId: string]: {
                    "name": string;
                    "description": string;
                    "help-url": string;
                    "properties": {
                        [propertyId: string]: LanguagePluginProperty;
                    },
                    "aceCategories": {
                        [categoryId: string]: string;
                    },
                    "conditions": {
                        [conditionId: string]: LanguageCondition;
                    },
                    "actions": {
                        [actionId: string]: LanguageAction;
                    },
                    "expressions": {
                        [expressionId: string]: LanguageExpression;
                    }
                }
            }
        }
    }

}

/**
 * aces.json
 */
export namespace Lost {

    export interface AcesJSON {
        [categoryName: string]: {
            "actions": AceAction[];
            "conditions": AceCondition[];
            "expressions": AceExpression[];
        }
    }

    interface Ace {
        "id": string;
        "isDeprecated": boolean;
        "highlight": boolean;
        "params": AceParam[];
    }

    export interface AceParam {
        "id": string;
        "type": Lost.ParamType;
        "initialValue": string;
        "items"?: string[];
        "allowedPluginIds"?: string[];
        "autocompleteId"?: boolean;
    }

    export interface AceAction extends Ace {
        "scriptName": string;
        "isAsync": boolean;
    }

    export interface AceCondition extends Ace {
        "scriptName": string;
        "isTrigger": boolean;
        "isFakeTrigger"?: boolean;
        "isStatic"?: boolean;
        "isLooping"?: boolean;
        "isInvertible"?: boolean;
        "isCompatibleWithTriggers"?: boolean;
    }

    export interface AceExpression extends Ace {
        "expressionName": string;
        "returnType": "number" | "string" | "any";
        "isVariadicParameters"?: boolean;
    }

}

/**
 * addon.json
 */
export namespace Lost {

    export type AddonType = "plugin";

    export interface AddonJSON {
        "min-construct-version"?: string;
        "is-c3-addon": true;
        "sdk-version": 2;
        "type": AddonType;
        "name": string;
        "id": string;
        "version": string;
        "author": string;
        "website": string;
        "documentation": string;
        "description": string;
        "editor-scripts": [
            "plugin.js",
            "type.js",
            "instance.js"
        ];
        "file-list": string[];
    } 

}

/**
 * Config
 */
export namespace Lost {

    /**
     * @description A script dependency that is included via the addition of an extra <script> tag in the exported HTML file, or loaded on the worker with importScripts() in worker mode. This means the script is always directly available to runtime code. However the dependency must be designed to work in a Web Worker, e.g. not assuming the DOM is present. The script is not minified on export.
    */
    export interface ExternalRuntimeScript {
        /**
         * Path to file without './libs'
         */
        FileName: string;
        Type: "external-runtime-script";
    }

    /**
     * @description A script dependency that is included via the addition of an extra <script> tag in the exported HTML file. The scriptType option can be set to "module" to load the script as a module (see below). Note in worker mode the script is loaded in the DOM, so is not directly available to the runtime code in the worker. The script is not minified on export. This is suitable for large external libraries that the addon references.
    */
   export  interface ExternalDomScript {
        /**
         * Path to file without './libs'
         */
        FileName: string;
        Type: "external-dom-script";
        /**
         * By default external DOM scripts are loaded as "classic" scripts. 
         * This property can be set to the string "module" to instead load the external DOM script as a module (i.e. with <script src="filename.js" type="module"></script>).
         */
        ScriptType?: "module";
    }

    /**
     * @description A stylesheet dependency that is included via the addition of an extra <link rel="stylesheet"> tag in the exported HTML file, in case the addon needs to specify CSS styles.
     */
    export interface ExternalCSSFile {
        /**
         * Path to file without './files'
         */
        FileName: string;
        Type: "external-css"
    }

    /**
     * @description This simply causes the file to be copied to the output folder when exporting. 
     * The file is also available in preview mode. 
     * This is useful for bundling additional resources, such as an image file that needs to be loaded at runtime, or a script that is dynamically loaded.
     */
    export interface CopyToOutputFile {
        /**
         * Path to file without './files'
         */
        FileName: string;
        Type: "copy-to-output"
    }

    interface Icon {
        /**
         * Icon file name with extension like .png OR .svg
         */
        FileName: string;
        /**
         * @png Set to 'image/png'
         * @svg Set to 'image/svg+xml'
         */
        Type: 'image/png' | 'image/svg+xml'
    }

    export interface Config {
        /**
         * The minimum Construct version required to load your addon, e.g. "r399". 
         * If not specified, the addon will be allowed to be installed with any version of Construct. 
         * If specified and the user attempts to install the addon with a version lower than the minimum, then Construct will prevent installation and show a message indicating that a newer version of Construct must be used. 
         * If the user installs the addon with a newer version of Construct and then rolls back to an older version of Construct lower than the minimum, then Construct will refuse to load the addon (a message will be logged to the console) and the editor will act as if the addon is not installed.
         */
        MinConstructVersion?: string;
        /**
         * The unique ID of the addon.
         *  This is not displayed and is only used internally.
         *  This must not be used by any other addon ever published for Construct 3, and must never change after you first publish your addon. 
         * (The name is the only visible identifier of the addon in the Construct 3 editor, so that can be changed any time, but the ID must always be the same.) 
         * To ensure it is unique, it is recommended to use a vendor-specific prefix, 
         * @example "MyCompany_MyAddon".
         */
        AddonId: string;
        /**
         * One of "plugin", "behavior", "effect" or "theme", indicating the kind of addon this is.
         */
        Type: Lost.AddonType;
        /**
         * Pass true to set the plugin to be a single-global type. 
         * The plugin type must be "object". Single-global plugins can only be added once to a project, and they then have a single permanent global instance available throughout the project. 
         * This is the mode that plugins like Touch and Audio use.
         */
        IsSingleGlobal?: boolean;
        /**
         * Set a boolean of whether the addon is deprecated or not. 
         * If you wish to replace your addon with another one, the old one can be deprecated with true. 
         * This makes it invisible in the editor so it cannot be used in new projects; however old projects with the addon already added can continue to load and work as they did before. 
         * This discourages use of the deprecated addon without breaking existing projects that use it.
         */
        IsDeprecated?: boolean;
        /**
         * Pass false to prevent the addon from being bundled via the Bundle addons project property. 
         * By default all addons may be bundled with a project, and it is recommended to leave this enabled for best user convenience. 
         * However if you publish a commercial addon and want to prevent it being distributed by project-bundling, you may wish to disable this.
         */
        CanBeBundled?: boolean;
        /**
         * The category of the addon.
         */
        AddonCategory: "data-and-storage" | "form-controls" | "general" | "input" | "media" | "monetisation" | "platform-specific" | "web" | "other";
        /**
         * The displayed name of the addon, in English.
         */
        AddonName: string;
        /**
         * A string of a brief description of what the addon does, displayed when prompting the user to install the addon.
         */
        AddonDescription: string;
        /**
         * A string specifying the addon version in four parts (major, minor, patch, revision)
         * @example "1.0.0.0"
         */
        Version: string;
        /**
         * A string identifying the author of the addon.
         */
        Author: string;
        /**
         * A string of a URL to the author's website. 
         * It is recommended to provide updates to the addon at this URL if any become available. 
         * The website should use HTTPS.
         */
        WebsiteURL: string;
        /**
         * A string of a URL to the online documentation for the addon. 
         * It is important to provide documentation for your addon to be useful to users.
         */
        DocsURL: string;
        /**
         * An object name that will applied after plugin was added to project.
         */
        ObjectName: string;
        /**
         * Setup your icon here
         */
        Icon: Icon;
        /**
         * Your scripts from 'libs' folder.
         */
        Scripts?: (ExternalDomScript | ExternalRuntimeScript)[];
        /**
         * Add a remote URL to load a script from.
         * @warning
         * The script URL must not use http: in its URL. On the modern web this will often be blocked from secure sites as mixed content. 
         * You must either use secure HTTPS, or a same-protocol URL like //example.com/api.js.
         */
        RemoteScripts?: string[];
        /**
         * Your files from 'files' folder.
         */
        Files?: (ExternalCSSFile | CopyToOutputFile)[];

        /**
         *  A boolean indicating whether the addon supports Construct's worker mode, where the entire runtime is hosted in a Web Worker instead of the main thread. 
         * This defaults to true. 
         * Providing the addon only uses APIs available in a Web Worker, then it is compatible; where access to the DOM is necessary, then a DOM script can be used to still access those features in worker mode - see Runtime scripts for more details. 
         * Therefore it should be possible for every addon to support worker mode, and supporting it is strongly recommended as worker mode can bring performance benefits. This can be set to false to indicate that the addon does not yet support worker mode, which may be useful to expedite addon development or if the addon makes use of extremely complex DOM operations. This will cause worker mode "auto" to switch to DOM mode which may degrade the performance of the project. If the user attempts to switch worker mode to "Yes" in project using the addon, then Construct will show an error message highlighting the addon that does not support the mode, and prevent changing the setting.
         */
        // SupportsWorkerMode: boolean;
    }

}

/**
 * Main
 */
export namespace Lost {

    export interface CategoryOptions {
        /**
         * If True, all category Actions/Conditions/Expressions will not include in addon.
         */
        readonly InDevelopment: boolean;
        /**
         * If True, all category Actions/Conditions/Expressions will mark as Deprecated.
         */
        readonly Deprecated?: boolean;
    }

    export class Category {
        readonly Id: string;
        readonly Name: string;
        readonly Actions: Lost.Action[];
        readonly Conditions: Lost.Condition[];
        readonly Expressions: Lost.Expression[];
        readonly Options: CategoryOptions;
        /**
         * 
         * @param Id Category Id
         * @param Name Category displayed name
         * @param Options Options object
         */
        constructor(Id: string, Name: string, Options: CategoryOptions) {
            this.Id = Id;
            this.Name = Name;
            this.Actions = [];
            this.Conditions = [];
            this.Expressions = [];
            this.Options = Options;

            const prototypeActions = Object.getPrototypeOf(this).Actions;
            if (prototypeActions) {
                this.Actions = prototypeActions;
            }

            const prototypeConditions = Object.getPrototypeOf(this).Conditions;
            if (prototypeConditions) {
                this.Conditions = prototypeConditions;
            }

            const prototypeExpressions = Object.getPrototypeOf(this).Expressions;
            if (prototypeExpressions) {
                this.Expressions = prototypeExpressions;
            }
        }
    }

    interface EntityOptions {
        ScriptName: string;
        Script: any;
        Highlight: boolean;
        Deprecated: boolean;
    }

    interface Entity {
        Id: string;
        Name: string;
        DisplayText: string;
        Description: string;
        Options: EntityOptions;
    }

    export interface Action extends Entity {
        Options: EntityOptions & {
            IsAsync: boolean;
        }
        Params: Param[];
    }

    export interface Condition extends Entity {
        Options: EntityOptions & {
            IsTrigger: boolean;
            IsFakeTrigger: boolean;
            IsStatic: boolean;
            IsLooping: boolean;
            IsInvertible: boolean;
            IsCompatibleWithTriggers: boolean;
        },
        Params: Param[];
    }

    export interface Expression extends Entity {
        Options: EntityOptions & {
            ReturnType: 'number' | 'string' | 'any';
            IsVariadicParameters: boolean;
        },
        Params: (StringParam | NumberParam | AnyParam)[]; 
    }

}

/**
 * Entities: Action, Condition, Expression
 */
export namespace Lost {

    interface EntityOptions {
        /**
         * A string specifying a unique ID for the ACE. 
         * This is used in the language file. 
         * By convention this is lowercase with dashes for separators, e.g. "my-condition".
         */
        Id: string,
        /**
         * The name that appears in the condition/action picker dialog.
         */
        Name: string,
        /**
         * The text that appears in the event sheet. 
         * You can use simple BBCode tags like [b] and [i], and use {0}, {1} etc. as parameter placeholders. 
         * (There must be one parameter placeholder per parameter.) 
         * For behaviors only, the placeholder {my} is substituted for the behavior name and icon.
         */
        DisplayText: string, 
        /**
         * A description of the action or condition, which appears as a tip at the top of the condition/action picker dialog.
         */
        Description?: string, 
    
        /**
         * Set to true to highlight the ACE in the condition/action/expression picker dialogs. 
         * This should only be used for the most regularly used ACEs, to help users pick them out from the list easily.
         */
        Highlight?: boolean;
        /**
         * Set to true to deprecate the ACE. 
         * This hides it in the editor, but allows existing projects to continue using it.
         */
        Deprecated?: boolean;
    }
    
    export interface ActionOptions extends EntityOptions {
        /**
         * Set to true to mark the action as asynchronous. 
         * Make the action method an async function, and the system Wait for previous actions to complete action will be able to wait for the action as well.
         */
        IsAsync?: boolean
        Params?: Param[];
    }
    
    export interface ConditionOptions extends EntityOptions {
        /**
         * Specifies a trigger condition. 
         * This appears with an arrow in the event sheet. 
         * Instead of being evaluated every tick, triggers only run when they are explicity triggered by a runtime call.
         */
        IsTrigger: boolean;
        /**
         * Specifies a fake trigger. 
         * This appears identical to a trigger in the event sheet, but is actually evaluated every tick. 
         * This is useful for conditions which are true for a single tick, such as for APIs which must poll a value every tick.
         */
        IsFakeTrigger?: boolean;
        /**
         * Normally, the condition runtime method is executed once per picked instance. 
         * If the condition is marked static, the runtime method is executed once only, on the object type class. 
         * This means the runtime method must also implement the instance picking entirely itself, including respecting negation and OR blocks.
         */
        IsStatic?: boolean;
        /**
         * Display an icon in the event sheet to indicate the condition loops. 
         * The condition method should use ILoopingConditionContext to implement its loop.
         * @link https://www.construct.net/en/make-games/manuals/construct-3/scripting/scripting-reference/addon-sdk-interfaces/iloopingconditioncontext
         */
        IsLooping?: boolean;
        /**
         * Allow the condition to be inverted in the event sheet. Set to false to disable invert.
         */
        IsInvertible?: boolean;
        /**
         * Allow the condition to be used in the same branch as a trigger. 
         * Set to false if the condition does not make sense when used in a trigger, such as the Trigger once condition.
         */
        IsCompatibleWithTriggers?: boolean;
        Params?: Param[];
    
    }
    
    export interface ExpressionOptions extends EntityOptions {
        /**
         * One of "number", "string", "any". 
         * The runtime function must return the corresponding type, and "any" must still return either a number or a string.
         */
        ReturnType: 'number' | 'string' | 'any',
        /**
         * If true, Construct 3 will allow the user to enter any number of parameters beyond those defined. 
         * In other words the parameters (if any) listed in "params" are required, but this flag enables adding further "any" type parameters beyond the end.
         */
        IsVariadicParameters?: boolean;
        Params?: (StringParam | NumberParam | AnyParam)[];
    }

}

export function Action(Options: Lost.ActionOptions) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {

        if (!target.constructor.prototype['Actions']) {
            target.constructor.prototype['Actions'] = [];
        }

        const Action: Lost.Action = {
            Id: Options.Id,
            Name: Options.Name,
            DisplayText: Options.DisplayText,
            Description: Options.Description || '',
            Options: {
                IsAsync: Options.IsAsync || false,

                ScriptName: propertyKey,
                Script: descriptor.value,
                Highlight: Options.Highlight || false,
                Deprecated: Options.Deprecated || false
            },
            Params: Options.Params || []
        }
        target.constructor.prototype.Actions.push(Action);
    };
}

export function Condition(Options: Lost.ConditionOptions) {
    return function (target: Lost.Category, propertyKey: string, descriptor: PropertyDescriptor) {

        if (!target.constructor.prototype['Conditions']) {
            target.constructor.prototype['Conditions'] = [];
        }

        const Condition: Lost.Condition = {
            Id: Options.Id,
            Name: Options.Name,
            DisplayText: Options.DisplayText,
            Description: Options.Description || '',
            Options: {
                IsTrigger: Options.IsTrigger,
                IsFakeTrigger: Options.IsFakeTrigger || false,
                IsStatic: Options.IsStatic || false,
                IsLooping: Options.IsLooping || false,
                IsInvertible: Options.IsInvertible || false,
                IsCompatibleWithTriggers: Options.IsCompatibleWithTriggers || true,

                ScriptName: propertyKey,
                Script: descriptor.value,
                Highlight: Options.Highlight || false,
                Deprecated: Options.Deprecated || false
            },
            Params: Options.Params || []
        }
        target.constructor.prototype.Conditions.push(Condition);
    };
}

export function Expression(Options: Lost.ExpressionOptions) {
    return function (target: Lost.Category, propertyKey: string, descriptor: PropertyDescriptor) {

        if (!target.constructor.prototype['Expressions']) {
            target.constructor.prototype['Expressions'] = [];
        }

        const Expression: Lost.Expression = {
            Id: Options.Id,
            Name: Options.Name,
            DisplayText: Options.DisplayText,
            Description: Options.Description || '',
            Options: {
                ReturnType: Options.ReturnType,
                IsVariadicParameters: Options.IsVariadicParameters || false,

                ScriptName: propertyKey,
                Script: descriptor.value,
                Highlight: Options.Highlight || false,
                Deprecated: Options.Deprecated || false
            },
            Params: Options.Params || []
        }
        target.constructor.prototype.Expressions.push(Expression);
    };
}

/**
 * Params
 */
export namespace Lost {

    export const enum ParamType { 
        NUMBER = "number", // a number parameter
        STRING = "string", // a string parameter
        ANY = "any", // either a number or a string
        BOOLEAN = "boolean", // a boolean parameter, displayed as a checkbox
        COMBO = "combo", // a dropdown list. Items must be specified with the "items" property.
        CMP = "cmp", // a dropdown list with comparison options like "equal to", "less than" etc.
        OBJECT = "object", // an object picker. The types of plugin to show can be filtered using an optional "allowedPluginIds" property.
        OBJECT_NAME = "objectname", // a string parameter which is interpreted as an object name
        LAYER = "layer", // a string parameter which is interpreted as a layer name
        LAYOUT = "layout", // a dropdown list with every layout in the project
        KEYB = "keyb", // a keyboard key picker
        INSTANCE_VAR = "instancevar", // a dropdown list with the non-boolean instance variables the object has
        INSTANCE_VAR_BOOL = "instancevarbool", // a dropdown list with the boolean instance variables the object has
        EVENT_VAR = "eventvar", // a dropdown list with non-boolean event variables in scope
        EVENT_VAR_BOOL = "eventvarbool", // a dropdown list with boolean event variables in scope,
        ANIMATION = "animation" // a string parameter which is interpreted as an animation name in the object
    
    }

    export type ParamOptionsType = ParamOptions | StringParamOptions | ComboParamOptions | ObjectParamOptions

    export abstract class Param {
        readonly Type: ParamType;
        readonly Options: ParamOptionsType;
        constructor(Options: ParamOptionsType, Type: ParamType) {
            this.Options = Options;
            this.Type = Type;
        };
    }

    export interface ParamOptions {
        /**
         * A string with a unique identifier for this parameter. This is used to refer to the parameter in the language file.
         */
        Id: string;
        /**
         * The name of the parameter
         */
        Name: string;
        /**
         * The parameter description
         */
        Description?: string;
        /**
         * A string which is used as the initial expression for expression-based parameters. 
         * Note this is still a string for "NumberParam" type parameters. 
         * It can contain any valid expression for the parameter, such as "1 + 1". 
         * For "BooleanParam" parameters, use a string of either "true" or "false". 
         * For "ComboParam" parameters, this is the initial item ID.
         */
        InitialValue?: string;
    }

    export interface StringParamOptions extends ParamOptions {
        /**
         * Set to a globally unique ID and string constants with the same ID will offer autocomplete in the editor. 
         * This is useful for "tag" parameters. 
         * Note the ID must be unique to all other plugins and behaviors in Construct, so it is a good idea to include your plugin or behavior name in the string, e.g. "myplugin-tag".
         */
        AutocompleteId?: boolean;
    } 

    export type ComboItem = {
        Id: string;
        Name: string;
    }

    export interface ComboParamOptions extends ParamOptions {
        /**
         * Set to an array of item IDs available in the dropdown list. 
         * The actual displayed text for the items is defined in variable.
         * @example 
         * @ComboParam({ Items: ["id1": "Name1", "id2": "Name2"] }) combo = "id1";
         */
        Items: ComboItem[];
    }

    export interface ObjectParamOptions extends ParamOptions {
        AllowedPluginIds?: string[];
    }

    // ALL PARAMS VARIABLE MUST IN STRING

}

/**
* @description A number parameter
*/
export class NumberParam extends Lost.Param { 
    constructor(Options: Lost.ParamOptions) {
        super(Options, Lost.ParamType.NUMBER);
    }
}

/**
 * @description A string parameter
 */
export class StringParam extends Lost.Param {
    constructor(Options: Lost.StringParamOptions) {
        super(Options, Lost.ParamType.STRING);
    }
}

/**
 * @description Either a number or a string
 */
export class AnyParam extends Lost.Param { 
    constructor(Options: Lost.ParamOptions) {
        super(Options, Lost.ParamType.ANY);
    }
}

/**
 * @description A boolean parameter, displayed as a checkbox
 */
export class BooleanParam extends Lost.Param { 
    constructor(Options: Lost.ParamOptions) {
        super(Options, Lost.ParamType.BOOLEAN);
    }
}

/**
 * @description A dropdown list. Items must be specified with the "Items" property.
 */
export class ComboParam extends Lost.Param { 
    constructor(Options: Lost.ComboParamOptions) {
        super(Options, Lost.ParamType.COMBO);
    }
}

/**
 * @description A dropdown list with comparison options like "equal to", "less than" etc.
 */
export class CmpParam extends Lost.Param { 
    constructor(Options: Lost.ParamOptions) {
        super(Options, Lost.ParamType.CMP);
    }
}

/**
 * @description An object picker. The types of plugin to show can be filtered using an optional "allowedPluginIds" property.
 */
export class ObjectParam extends Lost.Param { 
    constructor(Options: Lost.ObjectParamOptions) {
        super(Options, Lost.ParamType.OBJECT);
    }
}

/**
 * @description A string parameter which is interpreted as an object name
 */
export class ObjectNameParam extends Lost.Param { 
    constructor(Options: Lost.ParamOptions) {
        super(Options, Lost.ParamType.OBJECT_NAME);
    }
}

/**
 * @description A string parameter which is interpreted as a layer name
 */
export class LayerParam extends Lost.Param { 
    constructor(Options: Lost.ParamOptions) {
        super(Options, Lost.ParamType.LAYER);
    }
}

/**
 * @description A dropdown list with every layout in the project
 */
export class LayoutParam extends Lost.Param { 
    constructor(Options: Lost.ParamOptions) {
        super(Options, Lost.ParamType.LAYOUT);
    }
}

/**
 * @description A keyboard key picker
 */
export class KeybParam extends Lost.Param { 
    constructor(Options: Lost.ParamOptions) {
        super(Options, Lost.ParamType.KEYB);
    }
}

/**
 * @description A dropdown list with the non-boolean instance variables the object has
 */
export class InstanceVarParam extends Lost.Param { 
    constructor(Options: Lost.ParamOptions) {
        super(Options, Lost.ParamType.INSTANCE_VAR);
    }
}

/**
 * @description A dropdown list with the boolean instance variables the object has
 */
export class InstanceVarBoolParam extends Lost.Param { 
    constructor(Options: Lost.ParamOptions) {
        super(Options, Lost.ParamType.INSTANCE_VAR_BOOL);
    }
}

/**
 * @description A dropdown list with non-boolean event variables in scope
 */
export class EventVarParam extends Lost.Param { 
    constructor(Options: Lost.ParamOptions) {
        super(Options, Lost.ParamType.EVENT_VAR);
    }
}

/**
 * @description A dropdown list with boolean event variables in scope
 */
export class EventVarBoolParam extends Lost.Param { 
    constructor(Options: Lost.ParamOptions) {
        super(Options, Lost.ParamType.EVENT_VAR_BOOL);
    }
}

/**
 * @description A string parameter which is interpreted as an animation name in the object
 */
export class AnimationParam extends Lost.Param {
    constructor(Options: Lost.ParamOptions) {
        super(Options, Lost.ParamType.ANIMATION);
    }
}

/**
 * Plugin Properties
 */

export namespace Lost {
    export enum PluginPropertyType {
        INTEGER = "integer", /**
         * an integer number property, always rounded to a whole number.
         */
        FLOAT = "float", /**
         * a floating-point number property.
         */
        PERCENT = "percent", /**
         * a floating-point number in the range [0-1] represented as a percentage. 
        For example if the user enters 50%, the property will be set to a value of 0.5.
         */
        TEXT = "text", /**
         * a field the user can enter a string in to.
         */
        LONG_TEXT = "longtext", /**
         * the same as "text", but a button with an ellipsis ("...") appears on the right side of the field. 
        The user can click this button to open a dialog to edit a long string more conveniently. 
        This is useful for potentially long content like the project description, or the main text of the Text object.
         */
        CHECK = "check", /**
         * a checkbox property, returning a boolean.
         */
        FONT = "font", /**
         * a field which displays the name of a font and provides a button to open a font picker dialog. 
        The property is set to a string of the name of the font.
         */
        COMBO = "combo", /**
         * a dropdown list property. 
        The property is set to the zero-based index of the chosen item. 
        The items field of the options object must be used to specify the available items.
         */
        COLOR = "color", /**
         * For plugins only — a color picker property. 
        The initial value must be an array, e.g. [1, 0, 0] for red.
         */
        OBJECT = "object", /**
        For plugins only — an object picker property allowing the user to pick an object class. 
        Note: At runtime, this passes a SID (Serialization ID) for the chosen object class, or -1 if none was picked.
         Use the runtime method GetObjectClassBySID to look up the corresponding ObjectClass. 
         */
        GROUP = "group" /**
        creates a new group in the Properties Bar. There is no value associated with this property. 
        */
    }

    type PPOptions = PluginPropertyOptions | IntegerPropertyOptions | FloatPropertyOptions | PercentPropertyOptions | TextPropertyOptions | LongTextPropertyOptions | CheckPropertyOptions | FontPropertyOptions | ComboPropertyOptions | ColorPropertyOptions | ObjectPropertyOptions | GroupPropertyOptions;

    interface PluginPropertyOptions {
        Id: string;
        Name: string;
        Description?: string;
    }

    export abstract class PluginProperty {
        readonly Type: PluginPropertyType;
        readonly Options: PPOptions;
        constructor(Options: PPOptions, Type: PluginPropertyType) {
            this.Options = Options;
            this.Type = Type;
        }
    }

    export interface IntegerPropertyOptions extends PluginPropertyOptions {
        InitialValue: number;
    }

    export interface FloatPropertyOptions extends PluginPropertyOptions {
        InitialValue: number;
    }

    export interface PercentPropertyOptions extends PluginPropertyOptions {
        InitialValue: number;
    }

    export interface TextPropertyOptions extends PluginPropertyOptions {
        InitialValue: string;
    }

    export interface LongTextPropertyOptions extends PluginPropertyOptions {
        InitialValue: string;
    }

    export interface CheckPropertyOptions extends PluginPropertyOptions {
        InitialValue: boolean;
    }

    export interface FontPropertyOptions extends PluginPropertyOptions {
        /**
         * @description
         * Initial font-name
         */
        InitialValue: string;
    }

    export interface ComboPropertyOptions extends PluginPropertyOptions {
        InitialValue: string;
        Items: Lost.ComboItem[];
    }

    export interface ColorPropertyOptions extends PluginPropertyOptions {
        InitialValue: [number, number, number];
    }

    export interface ObjectPropertyOptions extends PluginPropertyOptions {
        AllowedPluginIds?: string[];
    }

    export interface GroupPropertyOptions extends PluginPropertyOptions {}

}

/**
 * @description
 * an integer number property, always rounded to a whole number.
 */
export class IntegerProperty extends Lost.PluginProperty {
    constructor(Options: Lost.IntegerPropertyOptions) {
        super(Options, Lost.PluginPropertyType.INTEGER);
    }
}

/**
 * @description
 * a floating-point number property.
 */
export class FloatProperty extends Lost.PluginProperty {
    constructor(Options: Lost.FloatPropertyOptions) {
        super(Options, Lost.PluginPropertyType.FLOAT);
    }
}

/**
 * @description
 * a floating-point number in the range [0-1] represented as a percentage. For example if the user enters 50%, the property will be set to a value of 0.5.
 */
export class PercentProperty extends Lost.PluginProperty {
    constructor(Options: Lost.PercentPropertyOptions) {
        if (Options.InitialValue > 1) Options.InitialValue = 1;
        if (Options.InitialValue < 0) Options.InitialValue = 0;
        super(Options, Lost.PluginPropertyType.PERCENT);
    }
}

/**
 * @description a field the user can enter a string in to.
 */
export class TextProperty extends Lost.PluginProperty {
    constructor(Options: Lost.TextPropertyOptions) {
        super(Options, Lost.PluginPropertyType.TEXT);
    }
}

/**
 * @description the same as "text", but a button with an ellipsis ("...") appears on the right side of the field. The user can click this button to open a dialog to edit a long string more conveniently. This is useful for potentially long content like the project description, or the main text of the Text object.
 */
export class LongTextProperty extends Lost.PluginProperty {
    constructor(Options: Lost.LongTextPropertyOptions) {
        super(Options, Lost.PluginPropertyType.LONG_TEXT);
    }
}

/**
 * @description a checkbox property, returning a boolean.
 */
export class CheckProperty extends Lost.PluginProperty {
    constructor(Options: Lost.CheckPropertyOptions) {
        super(Options, Lost.PluginPropertyType.CHECK);
    }
}

/**
 * @description a field which displays the name of a font and provides a button to open a font picker dialog. The property is set to a string of the name of the font.
 */
export class FontProperty extends Lost.PluginProperty {
    constructor(Options: Lost.FontPropertyOptions) {
        super(Options, Lost.PluginPropertyType.FONT);
    }
}

/**
 * @description a dropdown list property. The property is set to the zero-based index of the chosen item. The items field of the options object must be used to specify the available items.
 */
export class ComboProperty extends Lost.PluginProperty {
    constructor(Options: Lost.ComboPropertyOptions) {
        super(Options, Lost.PluginPropertyType.COMBO);
    }
}

/**
 * @description For plugins only — a color picker property. The initial value must be an array, e.g. [1, 0, 0] for red.
 */
export class ColorProperty extends Lost.PluginProperty {
    constructor(Options: Lost.ColorPropertyOptions) {
        super(Options, Lost.PluginPropertyType.COLOR);
    }
}

/**
 * @description For plugins only — an object picker property allowing the user to pick an object class. Note: At runtime, this passes a SID (Serialization ID) for the chosen object class, or -1 if none was picked. Use the runtime method GetObjectClassBySID to look up the corresponding ObjectClass.
 */
export class ObjectProperty extends Lost.PluginProperty {
    constructor(Options: Lost.ObjectPropertyOptions) {
        super(Options, Lost.PluginPropertyType.OBJECT);
    }
}

/**
 * @description creates a new group in the Properties Bar. There is no value associated with this property.
 */
export class GroupProperty extends Lost.PluginProperty {
    constructor(Options: Lost.GroupPropertyOptions) {
        super(Options, Lost.PluginPropertyType.GROUP);
    }
}

