import type { Condition } from "../system/Condition";
import type { Param } from "../../params/Param";
import type { EntityOptions } from "./Entity";
import type { LostCategory } from "../../category/Category";

interface ConditionOptions extends EntityOptions {
    /**
     * Specifies a trigger condition. 
     * This appears with an arrow in the event sheet. 
     * Instead of being evaluated every tick, triggers only run when they are explicity triggered by a runtime call.
     */
    IsTrigger: boolean;
    /**
     * Specifies a fake trigger. 
     * This appears identical to a trigger in the event sheet, but is actually evaluated every tick. 
     * This is useful for conditions which are true for a single tick, such as for APIs which must poll a value every tick.
     */
    IsFakeTrigger?: boolean;
    /**
     * Normally, the condition runtime method is executed once per picked instance. 
     * If the condition is marked static, the runtime method is executed once only, on the object type class. 
     * This means the runtime method must also implement the instance picking entirely itself, including respecting negation and OR blocks.
     */
    IsStatic?: boolean;
    /**
     * Display an icon in the event sheet to indicate the condition loops. 
     * The condition method should use ILoopingConditionContext to implement its loop.
     * @link https://www.construct.net/en/make-games/manuals/construct-3/scripting/scripting-reference/addon-sdk-interfaces/iloopingconditioncontext
     */
    IsLooping?: boolean;
    /**
     * Allow the condition to be inverted in the event sheet. Set to false to disable invert.
     */
    IsInvertible?: boolean;
    /**
     * Allow the condition to be used in the same branch as a trigger. 
     * Set to false if the condition does not make sense when used in a trigger, such as the Trigger once condition.
     */
    IsCompatibleWithTriggers?: boolean;
    Params?: Param[];

}

export function Condition(Options: ConditionOptions): any {
    return function (target: LostCategory, propertyKey: string, descriptor: PropertyDescriptor) {

        if (!target.constructor.prototype['Conditions']) {
            target.constructor.prototype['Conditions'] = [];
        }

        const Condition: Condition = {
            Id: Options.Id,
            Name: Options.Name,
            DisplayText: Options.DisplayText,
            Description: Options.Description || '',
            Options: {
                IsTrigger: Options.IsTrigger,
                IsFakeTrigger: Options.IsFakeTrigger || false,
                IsStatic: Options.IsStatic || false,
                IsLooping: Options.IsLooping || false,
                IsInvertible: Options.IsInvertible || false,
                IsCompatibleWithTriggers: Options.IsCompatibleWithTriggers || true,

                ScriptName: propertyKey,
                Script: descriptor.value,
                Highlight: Options.Highlight || false,
                Deprecated: Options.Deprecated || false
            },
            Params: Options.Params || []
        }
        target.constructor.prototype.Conditions.push(Condition);
    };
}