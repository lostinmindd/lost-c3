export declare enum AddonType {
    PLUGIN = "plugin",
    BEHAVIOR = "behavior"
}
/**
 * @description A script dependency that is included via the addition of an extra <script> tag in the exported HTML file, or loaded on the worker with importScripts() in worker mode. This means the script is always directly available to runtime code. However the dependency must be designed to work in a Web Worker, e.g. not assuming the DOM is present. The script is not minified on export.
*/
export interface ExternalRuntimeScript {
    /**
     * Path to file without './libs'
     */
    FileName: string;
    Type: "external-runtime-script";
}
/**
 * @description A script dependency that is included via the addition of an extra <script> tag in the exported HTML file. The scriptType option can be set to "module" to load the script as a module (see below). Note in worker mode the script is loaded in the DOM, so is not directly available to the runtime code in the worker. The script is not minified on export. This is suitable for large external libraries that the addon references.
*/
export interface ExternalDomScript {
    /**
     * Path to file without './libs'
     */
    FileName: string;
    Type: "external-dom-script";
    /**
     * By default external DOM scripts are loaded as "classic" scripts.
     * This property can be set to the string "module" to instead load the external DOM script as a module (i.e. with <script src="filename.js" type="module"></script>).
     */
    ScriptType?: "module";
}
/**
 * @description A stylesheet dependency that is included via the addition of an extra <link rel="stylesheet"> tag in the exported HTML file, in case the addon needs to specify CSS styles.
 */
export interface ExternalCSSFile {
    /**
     * Path to file without './files'
     */
    FileName: string;
    Type: "external-css";
}
/**
 * @description This simply causes the file to be copied to the output folder when exporting.
 * The file is also available in preview mode.
 * This is useful for bundling additional resources, such as an image file that needs to be loaded at runtime, or a script that is dynamically loaded.
 */
export interface CopyToOutputFile {
    /**
     * Path to file without './files'
     */
    FileName: string;
    Type: "copy-to-output";
}
interface Icon {
    /**
     * Icon file name with extension like .png OR .svg
     */
    FileName: string;
    /**
     * @png Set to 'image/png'
     * @svg Set to 'image/svg+xml'
     */
    Type: 'image/png' | 'image/svg+xml';
}
export type Config = PluginConfig | BehaviorConfig;
interface ConfigBase {
    /**
     * A boolean indicating whether the addon supports Construct's worker mode, where the entire runtime is hosted in a Web Worker instead of the main thread.
     * This defaults to true.
     * Providing the addon only uses APIs available in a Web Worker, then it is compatible; where access to the DOM is necessary, then a DOM script can be used to still access those features in worker mode - see Runtime scripts for more details.
     * Therefore it should be possible for every addon to support worker mode, and supporting it is strongly recommended as worker mode can bring performance benefits.
     * This can be set to false to indicate that the addon does not yet support worker mode, which may be useful to expedite addon development or if the addon makes use of extremely complex DOM operations.
     * This will cause worker mode "auto" to switch to DOM mode which may degrade the performance of the project.
     * If the user attempts to switch worker mode to "Yes" in project using the addon, then Construct will show an error message highlighting the addon that does not support the mode, and prevent changing the setting.
     */
    SupportsWorkerMode?: boolean;
    /**
     * The minimum Construct version required to load your addon, e.g. "r399".
     * If not specified, the addon will be allowed to be installed with any version of Construct.
     * If specified and the user attempts to install the addon with a version lower than the minimum, then Construct will prevent installation and show a message indicating that a newer version of Construct must be used.
     * If the user installs the addon with a newer version of Construct and then rolls back to an older version of Construct lower than the minimum, then Construct will refuse to load the addon (a message will be logged to the console) and the editor will act as if the addon is not installed.
     */
    MinConstructVersion?: string;
    /**
     * The unique ID of the addon.
     *  This is not displayed and is only used internally.
     *  This must not be used by any other addon ever published for Construct 3, and must never change after you first publish your addon.
     * (The name is the only visible identifier of the addon in the Construct 3 editor, so that can be changed any time, but the ID must always be the same.)
     * To ensure it is unique, it is recommended to use a vendor-specific prefix,
     * @example "MyCompany_MyAddon".
     */
    AddonId: string;
    /**
     * Set a boolean of whether the addon is deprecated or not.
     * If you wish to replace your addon with another one, the old one can be deprecated with true.
     * This makes it invisible in the editor so it cannot be used in new projects; however old projects with the addon already added can continue to load and work as they did before.
     * This discourages use of the deprecated addon without breaking existing projects that use it.
     */
    IsDeprecated?: boolean;
    /**
     * Pass false to prevent the addon from being bundled via the Bundle addons project property.
     * By default all addons may be bundled with a project, and it is recommended to leave this enabled for best user convenience.
     * However if you publish a commercial addon and want to prevent it being distributed by project-bundling, you may wish to disable this.
     */
    CanBeBundled?: boolean;
    /**
     * The displayed name of the addon, in English.
     */
    AddonName: string;
    /**
     * A string of a brief description of what the addon does, displayed when prompting the user to install the addon.
     */
    AddonDescription: string;
    /**
     * A string specifying the addon version in four parts (major, minor, patch, revision)
     * @example "1.0.0.0"
     */
    Version: string;
    /**
     * A string identifying the author of the addon.
     */
    Author: string;
    /**
     * A string of a URL to the author's website.
     * It is recommended to provide updates to the addon at this URL if any become available.
     * The website should use HTTPS.
     */
    WebsiteURL: string;
    /**
     * A string of a URL to the online documentation for the addon.
     * It is important to provide documentation for your addon to be useful to users.
     */
    DocsURL: string;
    /**
     * An object name that will applied after plugin was added to project.
     */
    ObjectName: string;
    /**
     * Setup your icon here
     */
    Icon: Icon;
    /**
     * Your scripts from 'libs' folder.
     */
    Scripts?: (ExternalDomScript | ExternalRuntimeScript)[];
    /**
     * Add a remote URL to load a script from.
     * @warning
     * The script URL must not use http: in its URL. On the modern web this will often be blocked from secure sites as mixed content.
     * You must either use secure HTTPS, or a same-protocol URL like //example.com/api.js.
     */
    RemoteScripts?: string[];
    /**
     * Your files from 'files' folder.
     */
    Files?: (ExternalCSSFile | CopyToOutputFile)[];
}
export type PluginCategory = "data-and-storage" | "form-controls" | "general" | "input" | "media" | "monetisation" | "platform-specific" | "web" | "other";
export type BehaviorCategory = "attributes" | "general" | "movements" | "other";
export interface PluginConfig extends ConfigBase {
    Type: AddonType.PLUGIN;
    /**
     * The category of the plugin.
     */
    Category: PluginCategory;
    /**
     * Pass true to set the plugin to be a single-global type.
     * The plugin type must be "object". Single-global plugins can only be added once to a project, and they then have a single permanent global instance available throughout the project.
     * This is the mode that plugins like Touch and Audio use.
     */
    IsSingleGlobal?: boolean;
}
export interface BehaviorConfig extends ConfigBase {
    Type: AddonType.BEHAVIOR;
    /**
     * The category of the plugin.
     */
    Category: BehaviorCategory;
    /**
     * Set a boolean of whether the behavior is allowed to be added more than once to the same object.
     * The default is false, which means the behavior can be added multiple times to the same object.
     * Set to true to only allow it to be added once to each object.
     */
    IsOnlyOneAllowed?: boolean;
}
export {};
