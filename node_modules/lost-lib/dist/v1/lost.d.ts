import { Param, NumberParam, StringParam, AnyParam, ParamType } from "./lost-params";
export declare function Deprecate(entity: Lost.Action.IAction | Lost.Condition.ICondition | Lost.Expression.IExpression): Lost.Action.IAction | Lost.Condition.ICondition | Lost.Expression.IExpression;
export declare namespace Lost {
    export interface IConfigScript {
        FileName: string;
        Type: "copy-to-output" | "inline-script" | "external-dom-script" | "external-runtime-script" | "external-css" | "wrapper-extension";
    }
    export interface IConfig {
        RemoveExportInJSFiles: boolean;
        AddonId: string;
        Type: AddonType;
        /**
         * @description The category for the plugin when displaying it in the Create New Object Type dialog.
         */
        Category: "3d" | "data-and-storage" | "form-controls" | "general" | "input" | "media" | "monetisation" | "platform-specific" | "web" | "other";
        /**
         * @description Set only when Type is "plugin"
         */
        IsSingleGlobal?: boolean;
        /**
         * @description Shows in addon install dialog
         */
        AddonName: string;
        /**
         * @description Shows in addon install dialog
         */
        AddonDescription: string;
        Version: string;
        Author: string;
        WebsiteURL: string;
        DocsURL: string;
        /**
         * @description Applying when creates an plugin object
         */
        ObjectName: string;
        Scripts: IConfigScript[];
    }
    type AddonType = "plugin";
    export interface IAddonJSON {
        "is-c3-addon": true;
        "sdk-version": 2;
        "type": AddonType;
        "name": string;
        "id": string;
        "version": string;
        "author": string;
        "website": string;
        "documentation": string;
        "description": string;
        "editor-scripts": string[];
        "file-list": string[];
    }
    export namespace AcesJSON {
        export interface IAcesJSON {
            [categoryName: string]: {
                "actions": IAceAction[];
                "conditions": IAceCondition[];
                "expressions": IAceExpression[];
            };
        }
        export interface IAceParam {
            "id": string;
            "type": ParamType;
            "initialValue": string;
            "items"?: string[];
            "allowedPluginIds"?: boolean;
            "autocompleteId"?: boolean;
        }
        interface IAce {
            "id": string;
            "isDeprecated": boolean;
            "highlight": boolean;
            "params": IAceParam[];
        }
        export interface IAceAction extends IAce {
            "scriptName": string;
            "isAsync": boolean;
        }
        export interface IAceCondition extends IAce {
            "scriptName": string;
            "isTrigger": boolean;
            "isFakeTrigger"?: boolean;
            "isStatic"?: boolean;
            "isLooping"?: boolean;
            "isInvertible"?: boolean;
            "isCompatibleWithTriggers"?: boolean;
        }
        export interface IAceExpression extends IAce {
            "expressionName": string;
            "returnType": "number" | "string" | "any";
            "isVariadicParameters"?: boolean;
        }
        export {};
    }
    export namespace LanguageJSON {
        interface ILanguageParam {
            "name": string;
            "desc": string;
            "items"?: {
                [itemId: string]: string;
            };
        }
        interface ILanguageCondition {
            /**
             * @description
             * the name that appears in the condition/action picker dialog.
             */
            "list-name": string;
            /**
             * @description
             * the text that appears in the event sheet.
             * You can use simple BBCode tags like [b] and [i], and use {0}, {1} etc. as parameter placeholders.
             * (There must be one parameter placeholder per parameter.)
             * For behaviors only, the placeholder {my} is substituted for the behavior name and icon.
             */
            "display-text": string;
            /**
             * @description
             * a description of the action or condition, which appears as a tip at the top of the condition/action picker dialog.
             */
            "description": string;
            "params"?: {
                [paramId: string]: ILanguageParam;
            };
        }
        interface ILanguageAction {
            /**
             * @description
             * the name that appears in the condition/action picker dialog.
             */
            "list-name": string;
            /**
             * @description
             * the text that appears in the event sheet.
             * You can use simple BBCode tags like [b] and [i], and use {0}, {1} etc. as parameter placeholders.
             * (There must be one parameter placeholder per parameter.)
             * For behaviors only, the placeholder {my} is substituted for the behavior name and icon.
             */
            "display-text": string;
            /**
             * @description
             * a description of the action or condition, which appears as a tip at the top of the condition/action picker dialog.
             */
            "description": string;
            "params"?: {
                [paramId: string]: ILanguageParam;
            };
        }
        interface ILanguageExpression {
            /**
             * @description
             * the description that appears in the expressions dictionary, which lists all available expressions.
             */
            "description": string;
            /**
             * @description
             * the translated name of the expression name.
             * In the en-US file, this should simply match the expression name from the expression definition.
             * This key mainly exists so it can be changed in other languages, making it possible to translate expressions in some contexts.
             * Note when actually typing an expression the non-translated expression name must always be used.
             */
            "translated-name": string;
            "params"?: {
                [paramId: string]: ILanguageParam;
            };
        }
        interface ILanguagePluginProperty {
            "name": string;
            "desc": string;
            "items"?: {
                [itemId: string]: string;
            };
        }
        interface enUSJSON {
            "languageTag": "en-US";
            "fileDescription": string;
            "text": {
                "plugins": {
                    [pluginId: string]: {
                        "name": string;
                        "description": string;
                        "help-url": string;
                        "properties": {
                            [propertyId: string]: ILanguagePluginProperty;
                        };
                        "aceCategories": {
                            [categoryId: string]: string;
                        };
                        "conditions": {
                            [conditionId: string]: ILanguageCondition;
                        };
                        "actions": {
                            [actionId: string]: ILanguageAction;
                        };
                        "expressions": {
                            [expressionId: string]: ILanguageExpression;
                        };
                    };
                };
            };
        }
    }
    export interface ICategory {
        Id: string;
        Name: string;
        Actions?: Lost.Action.IAction[];
        Conditions?: Lost.Condition.ICondition[];
        Expressions?: Lost.Expression.IExpression[];
    }
    export namespace Entity {
        interface IEntity {
            Id: string;
            Name: string;
            DisplayText: string;
            Description?: string;
            Options: IOptions;
        }
        interface IOptions {
            Script: Function;
            IsDeprecated?: boolean;
            Highlight?: boolean;
        }
    }
    export namespace Action {
        interface IOptions {
            /**
             * @description
             * Set to true to mark the action as asynchronous.
             * Make the action method an async function, and the system Wait for previous actions to complete action will be able to wait for the action as well.
             */
            IsAsync?: boolean;
        }
        export interface IAction extends Lost.Entity.IEntity {
            Options: Lost.Entity.IOptions & IOptions;
            Params?: Param[];
        }
        export {};
    }
    export namespace Condition {
        interface IOptions {
            /**
             * @description
             * Specifies a trigger condition.
             * This appears with an arrow in the event sheet.
             * Instead of being evaluated every tick, triggers only run when they are explicity triggered by a runtime call.
             */
            IsTrigger: boolean;
            /**
             * @description
             * Specifies a fake trigger.
             * This appears identical to a trigger in the event sheet, but is actually evaluated every tick.
             * This is useful for conditions which are true for a single tick, such as for APIs which must poll a value every tick.
             */
            IsFakeTrigger?: boolean;
            /**
             * @description
             * Normally, the condition runtime method is executed once per picked instance.
             * If the condition is marked static, the runtime method is executed once only, on the object type class.
             * This means the runtime method must also implement the instance picking entirely itself, including respecting negation and OR blocks.
             */
            IsStatic?: boolean;
            /**
             * @description Display an icon in the event sheet to indicate the condition loops. This should only be used with conditions which implement re-triggering.
             */
            IsLooping?: boolean;
            /**
             * @description
             * Allow the condition to be inverted in the event sheet. Set to false to disable invert.
             */
            IsInvertible?: boolean;
            /**
             * @description
             * Allow the condition to be used in the same branch as a trigger.
             * Set to false if the condition does not make sense when used in a trigger, such as the Trigger once condition.
             */
            IsCompatibleWithTriggers?: boolean;
        }
        export interface ICondition extends Lost.Entity.IEntity {
            Options: Lost.Entity.IOptions & IOptions;
            Params?: Param[];
        }
        export {};
    }
    export namespace Expression {
        interface IOptions {
            ReturnType: "number" | "string" | "any";
            /**
             * @description
             * If true, Construct 3 will allow the user to enter any number of parameters beyond those defined.
             * In other words the parameters (if any) listed in "params" are required, but this flag enables adding further "any" type parameters beyond the end.
             */
            IsVariadicParameters?: boolean;
        }
        export interface IExpression extends Lost.Entity.IEntity {
            Options: Lost.Entity.IOptions & IOptions;
            /**
             * @important
             * Use only @class NumberParam, StringParam, AnyParam
             */
            Params?: (NumberParam | StringParam | AnyParam)[];
        }
        export {};
    }
    export {};
}
